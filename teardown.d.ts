/// <reference types="@typescript-to-lua/language-extensions" />
// generated by teardown-ts-gen
/** @noSelfInFile **/
/**
 * @param {string} name_ Parameter name
 * @param {number} default_ Default parameter value
 * @returns {number} Parameter value
 */
declare function GetIntParam(name_: string, default_: number): number;
/**
 * @param {string} name_ Parameter name
 * @param {number} default_ Default parameter value
 * @returns {number} Parameter value
 */
declare function GetFloatParam(name_: string, default_: number): number;
/**
 * @param {string} name_ Parameter name
 * @param {boolean} default_ Default parameter value
 * @returns {boolean} Parameter value
 */
declare function GetBoolParam(name_: string, default_: boolean): boolean;
/**
 * @param {string} name_ Parameter name
 * @param {string} default_ Default parameter value
 * @returns {string} Parameter value
 */
declare function GetStringParam(name_: string, default_: string): string;
/**
 * @returns {string} Dot separated string of current version of the game
 */
declare function GetVersion(): string;
/**
 * @param {string} version_ Reference version
 * @returns {boolean} True if current version is at least provided one
 */
declare function HasVersion(version_: string): boolean;
/**
 * @returns {number} The time in seconds since level was started
 */
declare function GetTime(): number;
/**
 * @returns {number} The timestep in seconds
 */
declare function GetTimeStep(): number;
/**
 * @returns {string} Name of last pressed key, empty if no key is pressed
 */
declare function InputLastPressedKey(): string;
/**
 * @param {string} input_ The input identifier
 * @returns {boolean} True if input was pressed during last frame
 */
declare function InputPressed(input_: string): boolean;
/**
 * @param {string} input_ The input identifier
 * @returns {boolean} True if input was released during last frame
 */
declare function InputReleased(input_: string): boolean;
/**
 * @param {string} input_ The input identifier
 * @returns {boolean} True if input is currently held down
 */
declare function InputDown(input_: string): boolean;
/**
 * @param {string} input_ The input identifier
 * @returns {number} Depends on input type
 */
declare function InputValue(input_: string): number;
/**
 * @param {string} variable_ Name of number variable in the global context
 * @param {number} value_ The new value
 * @param {string} [transition_] Transition type. See description.
 * @param {number} [time_] Transition time (seconds)
 */
declare function SetValue(variable_: string, value_: number, transition_?: string, time_?: number): void;
/**
 * @param {string} title_ Text on button
 * @param {boolean} [primary_] Primary button
 * @returns {boolean} True if clicked, false otherwise
 */
declare function PauseMenuButton(title_: string, primary_?: boolean): boolean;
/**
 * @param {string} mission_ An identifier of your choice
 * @param {string} path_ Path to level XML file
 * @param {string} [layers_] Active layers. Default is no layers.
 * @param {boolean} [passThrough_] If set, loading screen will have no text and music will keep playing
 */
declare function StartLevel(mission_: string, path_: string, layers_?: string, passThrough_?: boolean): void;
/**
 * @param {boolean} paused_ True if game should be paused
 */
declare function SetPaused(paused_: boolean): void;
/**
 */
declare function Restart(): void;
/**
 */
declare function Menu(): void;
/**
 * @param {string} key_ Registry key to clear
 */
declare function ClearKey(key_: string): void;
/**
 * @param {string} parent_ The parent registry key
 * @returns {LuaTable} Indexed table of strings with child keys
 */
declare function ListKeys(parent_: string): LuaTable;
/**
 * @param {string} key_ Registry key
 * @returns {boolean} True if key exists
 */
declare function HasKey(key_: string): boolean;
/**
 * @param {string} key_ Registry key
 * @param {number} value_ Desired value
 */
declare function SetInt(key_: string, value_: number): void;
/**
 * @param {string} key_ Registry key
 * @returns {number} Integer value of registry node or zero if not found
 */
declare function GetInt(key_: string): number;
/**
 * @param {string} key_ Registry key
 * @param {number} value_ Desired value
 */
declare function SetFloat(key_: string, value_: number): void;
/**
 * @param {string} key_ Registry key
 * @returns {number} Float value of registry node or zero if not found
 */
declare function GetFloat(key_: string): number;
/**
 * @param {string} key_ Registry key
 * @param {boolean} value_ Desired value
 */
declare function SetBool(key_: string, value_: boolean): void;
/**
 * @param {string} key_ Registry key
 * @returns {boolean} Boolean value of registry node or false if not found
 */
declare function GetBool(key_: string): boolean;
/**
 * @param {string} key_ Registry key
 * @param {string} value_ Desired value
 */
declare function SetString(key_: string, value_: string): void;
/**
 * @param {string} key_ Registry key
 * @returns {string} String value of registry node or '' if not found
 */
declare function GetString(key_: string): string;
/**
 * @param {number} [x_] X value
 * @param {number} [y_] Y value
 * @param {number} [z_] Z value
 * @returns {LuaTable} New vector
 */
declare function Vec(x_?: number, y_?: number, z_?: number): LuaTable;
/**
 * @param {LuaTable} org_ A vector
 * @returns {LuaTable} Copy of org vector
 */
declare function VecCopy(org_: LuaTable): LuaTable;
/**
 * @param {LuaTable} vec_ A vector
 * @returns {number} Length (magnitude) of the vector
 */
declare function VecLength(vec_: LuaTable): number;
/**
 * @param {LuaTable} vec_ A vector
 * @returns {LuaTable} A vector of length 1.0
 */
declare function VecNormalize(vec_: LuaTable): LuaTable;
/**
 * @param {LuaTable} vec_ A vector
 * @param {number} scale_ A scale factor
 * @returns {LuaTable} A scaled version of input vector
 */
declare function VecScale(vec_: LuaTable, scale_: number): LuaTable;
/**
 * @param {LuaTable} a_ Vector
 * @param {LuaTable} b_ Vector
 * @returns {LuaTable} New vector with sum of a and b
 */
declare function VecAdd(a_: LuaTable, b_: LuaTable): LuaTable;
/**
 * @param {LuaTable} a_ Vector
 * @param {LuaTable} b_ Vector
 * @returns {LuaTable} New vector representing a-b
 */
declare function VecSub(a_: LuaTable, b_: LuaTable): LuaTable;
/**
 * @param {LuaTable} a_ Vector
 * @param {LuaTable} b_ Vector
 * @returns {number} Dot product of a and b
 */
declare function VecDot(a_: LuaTable, b_: LuaTable): number;
/**
 * @param {LuaTable} a_ Vector
 * @param {LuaTable} b_ Vector
 * @returns {LuaTable} Cross product of a and b (also called vector product)
 */
declare function VecCross(a_: LuaTable, b_: LuaTable): LuaTable;
/**
 * @param {LuaTable} a_ Vector
 * @param {LuaTable} b_ Vector
 * @param {number} t_ fraction (usually between 0.0 and 1.0)
 * @returns {LuaTable} Linearly interpolated vector between a and b, using t
 */
declare function VecLerp(a_: LuaTable, b_: LuaTable, t_: number): LuaTable;
/**
 * @param {number} [x_] X value
 * @param {number} [y_] Y value
 * @param {number} [z_] Z value
 * @param {number} [w_] W value
 * @returns {LuaTable} New quaternion
 */
declare function Quat(x_?: number, y_?: number, z_?: number, w_?: number): LuaTable;
/**
 * @param {LuaTable} org_ Quaternion
 * @returns {LuaTable} Copy of org quaternion
 */
declare function QuatCopy(org_: LuaTable): LuaTable;
/**
 * @param {LuaTable} axis_ Rotation axis, unit vector
 * @param {number} angle_ Rotation angle in degrees
 * @returns {LuaTable} New quaternion
 */
declare function QuatAxisAngle(axis_: LuaTable, angle_: number): LuaTable;
/**
 * @param {number} x_ Angle around X axis in degrees, sometimes also called roll or bank
 * @param {number} y_ Angle around Y axis in degrees, sometimes also called yaw or heading
 * @param {number} z_ Angle around Z axis in degrees, sometimes also called pitch or attitude
 * @returns {LuaTable} New quaternion
 */
declare function QuatEuler(x_: number, y_: number, z_: number): LuaTable;
/**
 * @param {LuaTable} quat_ Quaternion
 * @returns {number} Angle around X axis in degrees, sometimes also called roll or bank
 * @returns {number} Angle around Y axis in degrees, sometimes also called yaw or heading
 * @returns {number} Angle around Z axis in degrees, sometimes also called pitch or attitude
 */
declare function GetQuatEuler(quat_: LuaTable): LuaMultiReturn<[number, number, number]>;
/**
 * @param {LuaTable} eye_ Vector representing the camera location
 * @param {LuaTable} target_ Vector representing the point to look at
 * @returns {LuaTable} New quaternion
 */
declare function QuatLookAt(eye_: LuaTable, target_: LuaTable): LuaTable;
/**
 * @param {LuaTable} a_ Quaternion
 * @param {LuaTable} b_ Quaternion
 * @param {number} t_ fraction (usually between 0.0 and 1.0)
 * @returns {LuaTable} New quaternion
 */
declare function QuatSlerp(a_: LuaTable, b_: LuaTable, t_: number): LuaTable;
/**
 * @param {LuaTable} a_ Quaternion
 * @param {LuaTable} b_ Quaternion
 * @returns {LuaTable} New quaternion
 */
declare function QuatRotateQuat(a_: LuaTable, b_: LuaTable): LuaTable;
/**
 * @param {LuaTable} a_ Quaternion
 * @param {LuaTable} vec_ Vector
 * @returns {LuaTable} Rotated vector
 */
declare function QuatRotateVec(a_: LuaTable, vec_: LuaTable): LuaTable;
/**
 * @param {LuaTable} [pos_] Vector representing transform position
 * @param {LuaTable} [rot_] Quaternion representing transform rotation
 * @returns {LuaTable} New transform
 */
declare function Transform(pos_?: LuaTable, rot_?: LuaTable): LuaTable;
/**
 * @param {LuaTable} org_ Transform
 * @returns {LuaTable} Copy of org transform
 */
declare function TransformCopy(org_: LuaTable): LuaTable;
/**
 * @param {LuaTable} parent_ Transform
 * @param {LuaTable} child_ Transform
 * @returns {LuaTable} New transform
 */
declare function TransformToParentTransform(parent_: LuaTable, child_: LuaTable): LuaTable;
/**
 * @param {LuaTable} parent_ Transform
 * @param {LuaTable} child_ Transform
 * @returns {LuaTable} New transform
 */
declare function TransformToLocalTransform(parent_: LuaTable, child_: LuaTable): LuaTable;
/**
 * @param {LuaTable} t_ Transform
 * @param {LuaTable} v_ Vector
 * @returns {LuaTable} Transformed vector
 */
declare function TransformToParentVec(t_: LuaTable, v_: LuaTable): LuaTable;
/**
 * @param {LuaTable} t_ Transform
 * @param {LuaTable} v_ Vector
 * @returns {LuaTable} Transformed vector
 */
declare function TransformToLocalVec(t_: LuaTable, v_: LuaTable): LuaTable;
/**
 * @param {LuaTable} t_ Transform
 * @param {LuaTable} p_ Vector representing position
 * @returns {LuaTable} Transformed position
 */
declare function TransformToParentPoint(t_: LuaTable, p_: LuaTable): LuaTable;
/**
 * @param {LuaTable} t_ Transform
 * @param {LuaTable} p_ Vector representing position
 * @returns {LuaTable} Transformed position
 */
declare function TransformToLocalPoint(t_: LuaTable, p_: LuaTable): LuaTable;
/**
 * @param {number} handle_ Entity handle
 * @param {string} tag_ Tag name
 * @param {string} [value_] Tag value
 */
declare function SetTag(handle_: number, tag_: string, value_?: string): void;
/**
 * @param {number} handle_ Entity handle
 * @param {string} tag_ Tag name
 */
declare function RemoveTag(handle_: number, tag_: string): void;
/**
 * @param {number} handle_ Entity handle
 * @param {string} tag_ Tag name
 * @returns {boolean} Returns true if entity has tag
 */
declare function HasTag(handle_: number, tag_: string): boolean;
/**
 * @param {number} handle_ Entity handle
 * @param {string} tag_ Tag name
 * @returns {string} Returns the tag value, if any. Empty string otherwise.
 */
declare function GetTagValue(handle_: number, tag_: string): string;
/**
 * @param {number} handle_ Entity handle
 * @returns {LuaTable} Indexed table of tags on entity
 */
declare function ListTags(handle_: number): LuaTable;
/**
 * @param {number} handle_ Entity handle
 * @returns {string} The description string
 */
declare function GetDescription(handle_: number): string;
/**
 * @param {number} handle_ Entity handle
 * @param {string} description_ The description string
 */
declare function SetDescription(handle_: number, description_: string): void;
/**
 * @param {number} handle_ Entity handle
 */
declare function Delete(handle_: number): void;
/**
 * @param {number} handle_ Entity handle
 * @returns {boolean} Returns true if the entity pointed to by handle still exists
 */
declare function IsHandleValid(handle_: number): boolean;
/**
 * @param {number} handle_ Entity handle
 * @returns {string} Type name of the provided entity
 */
declare function GetEntityType(handle_: number): string;
/**
 * @param {string} tag_ Tag name
 * @param {boolean} [global_] Search in entire scene
 * @returns {number} Handle to first body with specified tag or zero if not found
 */
declare function FindBody(tag_: string, global_?: boolean): number;
/**
 * @param {string} tag_ Tag name
 * @param {boolean} [global_] Search in entire scene
 * @returns {LuaTable} Indexed table with handles to all bodies with specified tag
 */
declare function FindBodies(tag_: string, global_?: boolean): LuaTable;
/**
 * @param {number} handle_ Body handle
 * @returns {LuaTable} Transform of the body
 */
declare function GetBodyTransform(handle_: number): LuaTable;
/**
 * @param {number} handle_ Body handle
 * @param {LuaTable} transform_ Desired transform
 */
declare function SetBodyTransform(handle_: number, transform_: LuaTable): void;
/**
 * @param {number} handle_ Body handle
 * @returns {number} Body mass. Static bodies always return zero mass.
 */
declare function GetBodyMass(handle_: number): number;
/**
 * @param {number} handle_ Body handle
 * @returns {boolean} Return true if body is dynamic
 */
declare function IsBodyDynamic(handle_: number): boolean;
/**
 * @param {number} handle_ Body handle
 * @param {boolean} dynamic_ True for dynamic. False for static.
 */
declare function SetBodyDynamic(handle_: number, dynamic_: boolean): void;
/**
 * @param {number} handle_ Body handle (should be a dynamic body)
 * @param {LuaTable} velocity_ Vector with linear velocity
 */
declare function SetBodyVelocity(handle_: number, velocity_: LuaTable): void;
/**
 * @param {number} handle_ Body handle (should be a dynamic body)
 * @returns {LuaTable} Linear velocity as vector
 */
declare function GetBodyVelocity(handle_: number): LuaTable;
/**
 * @param {number} handle_ Body handle (should be a dynamic body)
 * @param {LuaTable} pos_ World space point as vector
 * @returns {LuaTable} Linear velocity on body at pos as vector
 */
declare function GetBodyVelocityAtPos(handle_: number, pos_: LuaTable): LuaTable;
/**
 * @param {number} handle_ Body handle (should be a dynamic body)
 * @param {LuaTable} angVel_ Vector with angular velocity
 */
declare function SetBodyAngularVelocity(handle_: number, angVel_: LuaTable): void;
/**
 * @param {number} handle_ Body handle (should be a dynamic body)
 * @returns {LuaTable} Angular velocity as vector
 */
declare function GetBodyAngularVelocity(handle_: number): LuaTable;
/**
 * @param {number} handle_ Body handle
 * @returns {boolean} Return true if body is active
 */
declare function IsBodyActive(handle_: number): boolean;
/**
 * @param {number} handle_ Body handle
 * @param {boolean} active_ Set to tru if body should be active (simulated)
 */
declare function SetBodyActive(handle_: number, active_: boolean): void;
/**
 * @param {number} handle_ Body handle (should be a dynamic body)
 * @param {LuaTable} position_ World space position as vector
 * @param {LuaTable} impulse_ World space impulse as vector
 */
declare function ApplyBodyImpulse(handle_: number, position_: LuaTable, impulse_: LuaTable): void;
/**
 * @param {number} handle_ Body handle
 * @returns {LuaTable} Indexed table of shape handles
 */
declare function GetBodyShapes(handle_: number): LuaTable;
/**
 * @param {number} body_ Body handle
 * @returns {number} Get parent vehicle for body, or zero if not part of vehicle
 */
declare function GetBodyVehicle(body_: number): number;
/**
 * @param {number} handle_ Body handle
 * @returns {LuaTable} Vector representing the AABB lower bound
 * @returns {LuaTable} Vector representing the AABB upper bound
 */
declare function GetBodyBounds(handle_: number): LuaMultiReturn<[LuaTable, LuaTable]>;
/**
 * @param {number} handle_ Body handle
 * @returns {LuaTable} Vector representing local center of mass in body space
 */
declare function GetBodyCenterOfMass(handle_: number): LuaTable;
/**
 * @param {number} handle_ Body handle
 * @param {number} maxDist_ Maximum visible distance
 * @param {boolean} [rejectTransparent_] See through transparent materials. Default false.
 * @returns {boolean} Return true if body is visible
 */
declare function IsBodyVisible(handle_: number, maxDist_: number, rejectTransparent_?: boolean): boolean;
/**
 * @param {number} handle_ Body handle
 * @returns {boolean} Return true if body is broken
 */
declare function IsBodyBroken(handle_: number): boolean;
/**
 * @param {number} handle_ Body handle
 * @returns {boolean} Return true if body is in any way connected to a static body
 */
declare function IsBodyJointedToStatic(handle_: number): boolean;
/**
 * @param {number} handle_ Body handle
 * @param {number} [r_] Red
 * @param {number} [g_] Green
 * @param {number} [b_] Blue
 * @param {number} a_ Alpha
 */
declare function DrawBodyOutline(handle_: number, r_?: number, g_?: number, b_?: number, a_: number): void;
/**
 * @param {number} handle_ Body handle
 * @param {number} amount_ Amount
 */
declare function DrawBodyHighlight(handle_: number, amount_: number): void;
/**
 * @param {number} body_ Body handle
 * @param {LuaTable} origin_ World space point
 * @returns {boolean} True if a point was found
 * @returns {LuaTable} World space closest point
 * @returns {LuaTable} World space normal at closest point
 * @returns {number} Handle to closest shape
 */
declare function GetBodyClosestPoint(body_: number, origin_: LuaTable): LuaMultiReturn<[boolean, LuaTable, LuaTable, number]>;
/**
 * @param {number} bodyA_ First body handle (zero for static)
 * @param {number} bodyB_ Second body handle (zero for static)
 * @param {LuaTable} point_ World space point
 * @param {LuaTable} dir_ World space direction
 * @param {number} relVel_ Desired relative velocity along the provided direction
 * @param {number} [min_] Minimum impulse (default: -infinity)
 * @param {number} [max_] Maximum impulse (default: infinity)
 */
declare function ConstrainVelocity(bodyA_: number, bodyB_: number, point_: LuaTable, dir_: LuaTable, relVel_: number, min_?: number, max_?: number): void;
/**
 * @param {number} bodyA_ First body handle (zero for static)
 * @param {number} bodyB_ Second body handle (zero for static)
 * @param {LuaTable} dir_ World space direction
 * @param {number} relAngVel_ Desired relative angular velocity along the provided direction
 * @param {number} [min_] Minimum angular impulse (default: -infinity)
 * @param {number} [max_] Maximum angular impulse (default: infinity)
 */
declare function ConstrainAngularVelocity(bodyA_: number, bodyB_: number, dir_: LuaTable, relAngVel_: number, min_?: number, max_?: number): void;
/**
 * @param {number} bodyA_ First body handle (zero for static)
 * @param {number} bodyB_ Second body handle (zero for static)
 * @param {LuaTable} pointA_ World space point for first body
 * @param {LuaTable} pointB_ World space point for second body
 * @param {number} [maxVel_] Maximum relative velocity (default: infinite)
 * @param {number} [maxImpulse_] Maximum impulse (default: infinite)
 */
declare function ConstrainPosition(bodyA_: number, bodyB_: number, pointA_: LuaTable, pointB_: LuaTable, maxVel_?: number, maxImpulse_?: number): void;
/**
 * @param {number} bodyA_ First body handle (zero for static)
 * @param {number} bodyB_ Second body handle (zero for static)
 * @param {LuaTable} quatA_ World space orientation for first body
 * @param {LuaTable} quatB_ World space orientation for second body
 * @param {number} [maxAngVel_] Maximum relative angular velocity (default: infinite)
 * @param {number} [maxAngImpulse_] Maximum angular impulse (default: infinite)
 */
declare function ConstrainOrientation(bodyA_: number, bodyB_: number, quatA_: LuaTable, quatB_: LuaTable, maxAngVel_?: number, maxAngImpulse_?: number): void;
/**
 * @returns {number} Handle to the static world body
 */
declare function GetWorldBody(): number;
/**
 * @param {string} tag_ Tag name
 * @param {boolean} [global_] Search in entire scene
 * @returns {number} Handle to first shape with specified tag or zero if not found
 */
declare function FindShape(tag_: string, global_?: boolean): number;
/**
 * @param {string} tag_ Tag name
 * @param {boolean} [global_] Search in entire scene
 * @returns {LuaTable} Indexed table with handles to all shapes with specified tag
 */
declare function FindShapes(tag_: string, global_?: boolean): LuaTable;
/**
 * @param {number} handle_ Shape handle
 * @returns {LuaTable} Return shape transform in body space
 */
declare function GetShapeLocalTransform(handle_: number): LuaTable;
/**
 * @param {number} handle_ Shape handle
 * @param {LuaTable} transform_ Shape transform in body space
 */
declare function SetShapeLocalTransform(handle_: number, transform_: LuaTable): void;
/**
 * @param {number} handle_ Shape handle
 * @returns {LuaTable} Return shape transform in world space
 */
declare function GetShapeWorldTransform(handle_: number): LuaTable;
/**
 * @param {number} handle_ Shape handle
 * @returns {number} Body handle
 */
declare function GetShapeBody(handle_: number): number;
/**
 * @param {number} shape_ Shape handle
 * @returns {LuaTable} Indexed table with joints connected to shape
 */
declare function GetShapeJoints(shape_: number): LuaTable;
/**
 * @param {number} shape_ Shape handle
 * @returns {LuaTable} Indexed table of lights owned by shape
 */
declare function GetShapeLights(shape_: number): LuaTable;
/**
 * @param {number} handle_ Shape handle
 * @returns {LuaTable} Vector representing the AABB lower bound
 * @returns {LuaTable} Vector representing the AABB upper bound
 */
declare function GetShapeBounds(handle_: number): LuaMultiReturn<[LuaTable, LuaTable]>;
/**
 * @param {number} handle_ Shape handle
 * @param {number} scale_ Scale factor for emissiveness
 */
declare function SetShapeEmissiveScale(handle_: number, scale_: number): void;
/**
 * @param {number} handle_ Shape handle
 * @param {LuaTable} pos_ Position in world space
 * @returns {string} Material type
 * @returns {number} Red
 * @returns {number} Green
 * @returns {number} Blue
 * @returns {number} Alpha
 * @returns {number} Palette entry for voxel (zero if empty)
 */
declare function GetShapeMaterialAtPosition(handle_: number, pos_: LuaTable): LuaMultiReturn<[string, number, number, number, number, number]>;
/**
 * @param {number} handle_ Shape handle
 * @param {number} x_ X integer coordinate
 * @param {number} y_ Y integer coordinate
 * @param {number} z_ Z integer coordinate
 * @returns {string} Material type
 * @returns {number} Red
 * @returns {number} Green
 * @returns {number} Blue
 * @returns {number} Alpha
 * @returns {number} Palette entry for voxel (zero if empty)
 */
declare function GetShapeMaterialAtIndex(handle_: number, x_: number, y_: number, z_: number): LuaMultiReturn<[string, number, number, number, number, number]>;
/**
 * @param {number} handle_ Shape handle
 * @returns {number} Size in voxels along x axis
 * @returns {number} Size in voxels along y axis
 * @returns {number} Size in voxels along z axis
 * @returns {number} The size of one voxel in meters (with default scale it is 0.1)
 */
declare function GetShapeSize(handle_: number): LuaMultiReturn<[number, number, number, number]>;
/**
 * @param {number} handle_ Shape handle
 * @returns {number} Number of voxels in shape
 */
declare function GetShapeVoxelCount(handle_: number): number;
/**
 * @param {number} handle_ Shape handle
 * @param {number} maxDist_ Maximum visible distance
 * @param {boolean} [rejectTransparent_] See through transparent materials. Default false.
 * @returns {boolean} Return true if shape is visible
 */
declare function IsShapeVisible(handle_: number, maxDist_: number, rejectTransparent_?: boolean): boolean;
/**
 * @param {number} handle_ Shape handle
 * @returns {boolean} Return true if shape is broken
 */
declare function IsShapeBroken(handle_: number): boolean;
/**
 * @param {number} handle_ Shape handle
 * @param {number} [r_] Red
 * @param {number} [g_] Green
 * @param {number} [b_] Blue
 * @param {number} a_ Alpha
 */
declare function DrawShapeOutline(handle_: number, r_?: number, g_?: number, b_?: number, a_: number): void;
/**
 * @param {number} handle_ Shape handle
 * @param {number} amount_ Amount
 */
declare function DrawShapeHighlight(handle_: number, amount_: number): void;
/**
 * @param {number} handle_ Shape handle
 * @param {number} layer_ Layer bits (0-255)
 * @param {number} mask_ Mask bits (0-255)
 */
declare function SetShapeCollisionFilter(handle_: number, layer_: number, mask_: number): void;
/**
 * @param {number} body_ Body handle
 * @param {LuaTable} transform_ Shape transform in body space
 * @param {number} refShape_ Handle to reference shape or path to vox file
 * @returns {number} Handle of new shape
 */
declare function CreateShape(body_: number, transform_: LuaTable, refShape_: number): number;
/**
 * @param {number} shape_ Shape handle
 */
declare function ClearShape(shape_: number): void;
/**
 * @param {number} shape_ Shape handle
 * @param {number} xmi_ Lower X coordinate
 * @param {number} ymi_ Lower Y coordinate
 * @param {number} zmi_ Lower Z coordinate
 * @param {number} xma_ Upper X coordinate
 * @param {number} yma_ Upper Y coordinate
 * @param {number} zma_ Upper Z coordinate
 * @returns {LuaTable} Offset vector in shape local space
 */
declare function ResizeShape(shape_: number, xmi_: number, ymi_: number, zmi_: number, xma_: number, yma_: number, zma_: number): LuaTable;
/**
 * @param {number} shape_ Shape handle
 * @param {number} body_ Body handle
 * @param {LuaTable} [transform_] New local shape transform. Default is existing local transform.
 */
declare function SetShapeBody(shape_: number, body_: number, transform_?: LuaTable): void;
/**
 * @param {number} src_ Source shape handle
 * @param {number} dst_ Destination shape handle
 */
declare function CopyShapeContent(src_: number, dst_: number): void;
/**
 * @param {number} src_ Source shape handle
 * @param {number} dst_ Destination shape handle
 */
declare function CopyShapePalette(src_: number, dst_: number): void;
/**
 * @param {number} shape_ Shape handle
 * @returns {LuaTable} Palette material entries
 */
declare function GetShapePalette(shape_: number): LuaTable;
/**
 * @param {number} shape_ Shape handle
 * @param {number} entry_ Material entry
 * @returns {string} Type
 * @returns {number} Red value
 * @returns {number} Green value
 * @returns {number} Blue value
 * @returns {number} Alpha value
 * @returns {number} Range 0 to 1
 * @returns {number} Range 0 to 1
 * @returns {number} Range 0 to 1
 * @returns {number} Range 0 to 32
 */
declare function GetShapeMaterial(shape_: number, entry_: number): LuaMultiReturn<[string, number, number, number, number, number, number, number, number]>;
/**
 * @param {string} type_ One of 'sphere', 'cube' or 'noise'
 * @param {number} size_ Size of brush in voxels (must be in range 1 to 16)
 * @param {string} index_ Material index or path to brush vox file
 * @param {string} [object_] Optional object in brush vox file if brush vox file is used
 */
declare function SetBrush(type_: string, size_: number, index_: string, object_?: string): void;
/**
 * @param {number} shape_ Handle to shape
 * @param {number} x0_ Start X coordinate
 * @param {number} y0_ Start Y coordinate
 * @param {number} z0_ Start Z coordinate
 * @param {number} x1_ End X coordinate
 * @param {number} y1_ End Y coordinate
 * @param {number} z1_ End Z coordinate
 * @param {boolean} [paint_] Paint mode. Default is false.
 * @param {boolean} [noOverwrite_] Only fill in voxels if space isn't already occupied. Default is false.
 */
declare function DrawShapeLine(shape_: number, x0_: number, y0_: number, z0_: number, x1_: number, y1_: number, z1_: number, paint_?: boolean, noOverwrite_?: boolean): void;
/**
 * @param {number} shape_ Handle to shape
 * @param {number} x0_ Start X coordinate
 * @param {number} y0_ Start Y coordinate
 * @param {number} z0_ Start Z coordinate
 * @param {number} x1_ End X coordinate
 * @param {number} y1_ End Y coordinate
 * @param {number} z1_ End Z coordinate
 */
declare function DrawShapeBox(shape_: number, x0_: number, y0_: number, z0_: number, x1_: number, y1_: number, z1_: number): void;
/**
 * @param {number} shape_ Handle to shape
 * @param {number} x_ X coordinate to extrude
 * @param {number} y_ Y coordinate to extrude
 * @param {number} z_ Z coordinate to extrude
 * @param {number} dx_ X component of extrude direction, should be -1, 0 or 1
 * @param {number} dy_ Y component of extrude direction, should be -1, 0 or 1
 * @param {number} dz_ Z component of extrude direction, should be -1, 0 or 1
 * @param {number} steps_ Length of extrusion in voxels
 * @param {string} mode_ Extrusion mode, one of 'exact', 'material', 'geometry'. Default is 'exact'
 */
declare function ExtrudeShape(shape_: number, x_: number, y_: number, z_: number, dx_: number, dy_: number, dz_: number, steps_: number, mode_: string): void;
/**
 * @param {number} shape_ Source handle
 * @returns {LuaTable} Offset vector in shape local space
 */
declare function TrimShape(shape_: number): LuaTable;
/**
 * @param {number} shape_ Source handle
 * @param {boolean} removeResidual_ Remove residual shapes (default false)
 * @returns {LuaTable} List of shape handles created
 */
declare function SplitShape(shape_: number, removeResidual_: boolean): LuaTable;
/**
 * @param {number} shape_ Input shape
 * @returns {number} Shape handle after merge
 */
declare function MergeShape(shape_: number): number;
/**
 * @param {number} shape_ Shape handle
 * @param {LuaTable} origin_ World space point
 * @returns {boolean} True if a point was found
 * @returns {LuaTable} World space closest point
 * @returns {LuaTable} World space normal at closest point
 */
declare function GetShapeClosestPoint(shape_: number, origin_: LuaTable): LuaMultiReturn<[boolean, LuaTable, LuaTable]>;
/**
 * @param {number} a_ Handle to first shape
 * @param {number} b_ Handle to second shape
 * @returns {boolean} True is shapes a and b are touching each other
 */
declare function IsShapeTouching(a_: number, b_: number): boolean;
/**
 * @param {string} tag_ Tag name
 * @param {boolean} [global_] Search in entire scene
 * @returns {number} Handle to first location with specified tag or zero if not found
 */
declare function FindLocation(tag_: string, global_?: boolean): number;
/**
 * @param {string} tag_ Tag name
 * @param {boolean} [global_] Search in entire scene
 * @returns {LuaTable} Indexed table with handles to all locations with specified tag
 */
declare function FindLocations(tag_: string, global_?: boolean): LuaTable;
/**
 * @param {number} handle_ Location handle
 * @returns {LuaTable} Transform of the location
 */
declare function GetLocationTransform(handle_: number): LuaTable;
/**
 * @param {string} tag_ Tag name
 * @param {boolean} [global_] Search in entire scene
 * @returns {number} Handle to first joint with specified tag or zero if not found
 */
declare function FindJoint(tag_: string, global_?: boolean): number;
/**
 * @param {string} tag_ Tag name
 * @param {boolean} [global_] Search in entire scene
 * @returns {LuaTable} Indexed table with handles to all joints with specified tag
 */
declare function FindJoints(tag_: string, global_?: boolean): LuaTable;
/**
 * @param {number} joint_ Joint handle
 * @returns {boolean} True if joint is broken
 */
declare function IsJointBroken(joint_: number): boolean;
/**
 * @param {number} joint_ Joint handle
 * @returns {string} Joint type
 */
declare function GetJointType(joint_: number): string;
/**
 * @param {number} joint_ Joint handle
 * @param {number} shape_ Shape handle
 * @returns {number} Other shape handle
 */
declare function GetJointOtherShape(joint_: number, shape_: number): number;
/**
 * @param {number} joint_ Joint handle
 * @returns {number} Shape handles
 */
declare function GetJointShapes(joint_: number): number;
/**
 * @param {number} joint_ Joint handle
 * @param {number} velocity_ Desired velocity
 * @param {number} [strength_] Desired strength. Default is infinite. Zero to disable.
 */
declare function SetJointMotor(joint_: number, velocity_: number, strength_?: number): void;
/**
 * @param {number} joint_ Joint handle
 * @param {number} target_ Desired movement target
 * @param {number} [maxVel_] Maximum velocity to reach target. Default is infinite.
 * @param {number} [strength_] Desired strength. Default is infinite. Zero to disable.
 */
declare function SetJointMotorTarget(joint_: number, target_: number, maxVel_?: number, strength_?: number): void;
/**
 * @param {number} joint_ Joint handle
 * @returns {number} Minimum joint limit (angle or distance)
 * @returns {number} Maximum joint limit (angle or distance)
 */
declare function GetJointLimits(joint_: number): LuaMultiReturn<[number, number]>;
/**
 * @param {number} joint_ Joint handle
 * @returns {number} Current joint position or angle
 */
declare function GetJointMovement(joint_: number): number;
/**
 * @param {number} body_ Body handle (must be dynamic)
 * @returns {LuaTable} Handles to all dynamic bodies in the jointed structure. The input handle will also be included.
 */
declare function GetJointedBodies(body_: number): LuaTable;
/**
 * @param {number} joint_ Joint handle
 * @param {number} shape_ Shape handle
 */
declare function DetachJointFromShape(joint_: number, shape_: number): void;
/**
 * @param {string} tag_ Tag name
 * @param {boolean} [global_] Search in entire scene
 * @returns {number} Handle to first light with specified tag or zero if not found
 */
declare function FindLight(tag_: string, global_?: boolean): number;
/**
 * @param {string} tag_ Tag name
 * @param {boolean} [global_] Search in entire scene
 * @returns {LuaTable} Indexed table with handles to all lights with specified tag
 */
declare function FindLights(tag_: string, global_?: boolean): LuaTable;
/**
 * @param {number} handle_ Light handle
 * @param {boolean} enabled_ Set to true if light should be enabled
 */
declare function SetLightEnabled(handle_: number, enabled_: boolean): void;
/**
 * @param {number} handle_ Light handle
 * @param {number} r_ Red value
 * @param {number} g_ Green value
 * @param {number} b_ Blue value
 */
declare function SetLightColor(handle_: number, r_: number, g_: number, b_: number): void;
/**
 * @param {number} handle_ Light handle
 * @param {number} intensity_ Desired intensity of the light
 */
declare function SetLightIntensity(handle_: number, intensity_: number): void;
/**
 * @param {number} handle_ Light handle
 * @returns {LuaTable} World space light transform
 */
declare function GetLightTransform(handle_: number): LuaTable;
/**
 * @param {number} handle_ Light handle
 * @returns {number} Shape handle or zero if not attached to shape
 */
declare function GetLightShape(handle_: number): number;
/**
 * @param {number} handle_ Light handle
 * @returns {boolean} True if light is currently emitting light
 */
declare function IsLightActive(handle_: number): boolean;
/**
 * @param {number} handle_ Light handle
 * @param {LuaTable} point_ World space point as vector
 * @returns {boolean} Return true if point is in light cone and range
 */
declare function IsPointAffectedByLight(handle_: number, point_: LuaTable): boolean;
/**
 * @param {string} tag_ Tag name
 * @param {boolean} [global_] Search in entire scene
 * @returns {number} Handle to first trigger with specified tag or zero if not found
 */
declare function FindTrigger(tag_: string, global_?: boolean): number;
/**
 * @param {string} tag_ Tag name
 * @param {boolean} [global_] Search in entire scene
 * @returns {LuaTable} Indexed table with handles to all triggers with specified tag
 */
declare function FindTriggers(tag_: string, global_?: boolean): LuaTable;
/**
 * @param {number} handle_ Trigger handle
 * @returns {LuaTable} Current trigger transform in world space
 */
declare function GetTriggerTransform(handle_: number): LuaTable;
/**
 * @param {number} handle_ Trigger handle
 * @param {LuaTable} transform_ Desired trigger transform in world space
 */
declare function SetTriggerTransform(handle_: number, transform_: LuaTable): void;
/**
 * @param {number} handle_ Trigger handle
 * @returns {LuaTable} Lower point of trigger bounds in world space
 * @returns {LuaTable} Upper point of trigger bounds in world space
 */
declare function GetTriggerBounds(handle_: number): LuaMultiReturn<[LuaTable, LuaTable]>;
/**
 * @param {number} trigger_ Trigger handle
 * @param {number} body_ Body handle
 * @returns {boolean} True if body is in trigger volume
 */
declare function IsBodyInTrigger(trigger_: number, body_: number): boolean;
/**
 * @param {number} trigger_ Trigger handle
 * @param {number} vehicle_ Vehicle handle
 * @returns {boolean} True if vehicle is in trigger volume
 */
declare function IsVehicleInTrigger(trigger_: number, vehicle_: number): boolean;
/**
 * @param {number} trigger_ Trigger handle
 * @param {number} shape_ Shape handle
 * @returns {boolean} True if shape is in trigger volume
 */
declare function IsShapeInTrigger(trigger_: number, shape_: number): boolean;
/**
 * @param {number} trigger_ Trigger handle
 * @param {LuaTable} point_ Word space point as vector
 * @returns {boolean} True if point is in trigger volume
 */
declare function IsPointInTrigger(trigger_: number, point_: LuaTable): boolean;
/**
 * @param {number} handle_ Trigger handle
 * @param {boolean} [demolision_] If true, small debris and vehicles are ignored
 * @returns {boolean} True if trigger is empty
 * @returns {LuaTable} World space point of highest point (largest Y coordinate) if not empty
 */
declare function IsTriggerEmpty(handle_: number, demolision_?: boolean): LuaMultiReturn<[boolean, LuaTable]>;
/**
 * @param {number} trigger_ Trigger handle
 * @param {LuaTable} point_ Word space point as vector
 * @returns {number} Positive if point is outside, negative if inside
 */
declare function GetTriggerDistance(trigger_: number, point_: LuaTable): number;
/**
 * @param {number} trigger_ Trigger handle
 * @param {LuaTable} point_ Word space point as vector
 * @returns {LuaTable} Closest point in trigger as vector
 */
declare function GetTriggerClosestPoint(trigger_: number, point_: LuaTable): LuaTable;
/**
 * @param {string} tag_ Tag name
 * @param {boolean} [global_] Search in entire scene
 * @returns {number} Handle to first screen with specified tag or zero if not found
 */
declare function FindScreen(tag_: string, global_?: boolean): number;
/**
 * @param {string} tag_ Tag name
 * @param {boolean} [global_] Search in entire scene
 * @returns {LuaTable} Indexed table with handles to all screens with specified tag
 */
declare function FindScreens(tag_: string, global_?: boolean): LuaTable;
/**
 * @param {number} screen_ Screen handle
 * @param {boolean} enabled_ True if screen should be enabled
 */
declare function SetScreenEnabled(screen_: number, enabled_: boolean): void;
/**
 * @param {number} screen_ Screen handle
 * @returns {boolean} True if screen is enabled
 */
declare function IsScreenEnabled(screen_: number): boolean;
/**
 * @param {number} screen_ Screen handle
 * @returns {number} Shape handle or zero if none
 */
declare function GetScreenShape(screen_: number): number;
/**
 * @param {string} tag_ Tag name
 * @param {boolean} [global_] Search in entire scene
 * @returns {number} Handle to first vehicle with specified tag or zero if not found
 */
declare function FindVehicle(tag_: string, global_?: boolean): number;
/**
 * @param {string} tag_ Tag name
 * @param {boolean} [global_] Search in entire scene
 * @returns {LuaTable} Indexed table with handles to all vehicles with specified tag
 */
declare function FindVehicles(tag_: string, global_?: boolean): LuaTable;
/**
 * @param {number} vehicle_ Vehicle handle
 * @returns {LuaTable} Transform of vehicle
 */
declare function GetVehicleTransform(vehicle_: number): LuaTable;
/**
 * @param {number} vehicle_ Vehicle handle
 * @returns {number} Main body of vehicle
 */
declare function GetVehicleBody(vehicle_: number): number;
/**
 * @param {number} vehicle_ Vehicle handle
 * @returns {number} Vehicle health (zero to one)
 */
declare function GetVehicleHealth(vehicle_: number): number;
/**
 * @param {number} vehicle_ Vehicle handle
 * @returns {LuaTable} Driver position as vector in vehicle space
 */
declare function GetVehicleDriverPos(vehicle_: number): LuaTable;
/**
 * @param {number} vehicle_ Vehicle handle
 * @param {number} drive_ Reverse/forward control -1 to 1
 * @param {number} steering_ Left/right control -1 to 1
 * @param {boolean} handbrake_ Handbrake control
 */
declare function DriveVehicle(vehicle_: number, drive_: number, steering_: number, handbrake_: boolean): void;
/**
 * @returns {LuaTable} Player center position
 */
declare function GetPlayerPos(): LuaTable;
/**
 * @param {boolean} includePitch_ Include the player pitch (look up/down) in transform
 * @returns {LuaTable} Current player transform
 */
declare function GetPlayerTransform(includePitch_: boolean): LuaTable;
/**
 * @param {LuaTable} transform_ Desired player transform
 * @param {boolean} includePitch_ Set player pitch (look up/down) as well
 */
declare function SetPlayerTransform(transform_: LuaTable, includePitch_: boolean): void;
/**
 * @param {LuaTable} vel_ Desired ground velocity
 */
declare function SetPlayerGroundVelocity(vel_: LuaTable): void;
/**
 * @returns {LuaTable} Current player camera transform
 */
declare function GetPlayerCameraTransform(): LuaTable;
/**
 * @param {LuaTable} transform_ Desired player camera offset transform
 */
declare function SetPlayerCameraOffsetTransform(transform_: LuaTable): void;
/**
 * @param {LuaTable} transform_ Desired player spawn transform
 */
declare function SetPlayerSpawnTransform(transform_: LuaTable): void;
/**
 * @returns {LuaTable} Player velocity in world space as vector
 */
declare function GetPlayerVelocity(): LuaTable;
/**
 * @param {number} vehicle_ Handle to vehicle or zero to not drive.
 */
declare function SetPlayerVehicle(vehicle_: number): void;
/**
 * @param {LuaTable} velocity_ Player velocity in world space as vector
 */
declare function SetPlayerVelocity(velocity_: LuaTable): void;
/**
 * @returns {number} Current vehicle handle, or zero if not in vehicle
 */
declare function GetPlayerVehicle(): number;
/**
 * @returns {number} Handle to grabbed shape or zero if not grabbing.
 */
declare function GetPlayerGrabShape(): number;
/**
 * @returns {number} Handle to grabbed body or zero if not grabbing.
 */
declare function GetPlayerGrabBody(): number;
/**
 */
declare function ReleasePlayerGrab(): void;
/**
 * @returns {number} Handle to picked shape or zero if nothing is picked
 */
declare function GetPlayerPickShape(): number;
/**
 * @returns {number} Handle to picked body or zero if nothing is picked
 */
declare function GetPlayerPickBody(): number;
/**
 * @returns {number} Handle to interactable shape or zero
 */
declare function GetPlayerInteractShape(): number;
/**
 * @returns {number} Handle to interactable body or zero
 */
declare function GetPlayerInteractBody(): number;
/**
 * @param {number} handle_ Handle to screen or zero for no screen
 */
declare function SetPlayerScreen(handle_: number): void;
/**
 * @returns {number} Handle to interacted screen or zero if none
 */
declare function GetPlayerScreen(): number;
/**
 * @param {number} health_ Set player health (between zero and one)
 */
declare function SetPlayerHealth(health_: number): void;
/**
 * @returns {number} Current player health
 */
declare function GetPlayerHealth(): number;
/**
 */
declare function RespawnPlayer(): void;
/**
 * @param {string} id_ Tool unique identifier
 * @param {string} name_ Tool name to show in hud
 * @param {string} file_ Path to vox file
 * @param {number} [group_] Tool group for this tool (1-6) Default is 6.
 */
declare function RegisterTool(id_: string, name_: string, file_: string, group_?: number): void;
/**
 * @returns {number} Handle to currently visible tool body or zero if none
 */
declare function GetToolBody(): number;
/**
 * @param {LuaTable} transform_ Tool body transform
 * @param {number} sway_ Tool sway amount. Default is 1.0.
 */
declare function SetToolTransform(transform_: LuaTable, sway_: number): void;
/**
 * @param {string} path_ Path to ogg sound file
 * @param {number} [nominalDistance_] The distance in meters this sound is recorded at. Affects attenuation, default is 10.0
 * @returns {number} Sound handle
 */
declare function LoadSound(path_: string, nominalDistance_?: number): number;
/**
 * @param {string} path_ Path to ogg sound file
 * @param {number} [nominalDistance_] The distance in meters this sound is recorded at. Affects attenuation, default is 10.0
 * @returns {number} Loop handle
 */
declare function LoadLoop(path_: string, nominalDistance_?: number): number;
/**
 * @param {number} handle_ Sound handle
 * @param {LuaTable} [pos_] World position as vector. Default is player position.
 * @param {number} [volume_] Playback volume. Default is 1.0
 */
declare function PlaySound(handle_: number, pos_?: LuaTable, volume_?: number): void;
/**
 * @param {number} handle_ Loop handle
 * @param {LuaTable} [pos_] World position as vector. Default is player position.
 * @param {number} [volume_] Playback volume. Default is 1.0
 */
declare function PlayLoop(handle_: number, pos_?: LuaTable, volume_?: number): void;
/**
 * @param {string} path_ Music path
 */
declare function PlayMusic(path_: string): void;
/**
 */
declare function StopMusic(): void;
/**
 * @param {string} path_ Path to sprite. Must be PNG or JPG format.
 * @returns {number} Sprite handle
 */
declare function LoadSprite(path_: string): number;
/**
 * @param {number} handle_ Sprite handle
 * @param {LuaTable} transform_ Transform
 * @param {number} width_ Width in meters
 * @param {number} height_ Height in meters
 * @param {number} [r_] Red color. Default 1.0.
 * @param {number} [g_] Green color. Default 1.0.
 * @param {number} [b_] Blue color. Default 1.0.
 * @param {number} [a_] Alpha. Default 1.0.
 * @param {boolean} [depthTest_] Depth test enabled. Default false.
 * @param {boolean} [additive_] Additive blending enabled. Default false.
 */
declare function DrawSprite(handle_: number, transform_: LuaTable, width_: number, height_: number, r_?: number, g_?: number, b_?: number, a_?: number, depthTest_?: boolean, additive_?: boolean): void;
/**
 * @param {string} layers_ Space separate list of layers
 */
declare function QueryRequire(layers_: string): void;
/**
 * @param {number} vehicle_ Vehicle handle
 */
declare function QueryRejectVehicle(vehicle_: number): void;
/**
 * @param {number} body_ Body handle
 */
declare function QueryRejectBody(body_: number): void;
/**
 * @param {number} shape_ Shape handle
 */
declare function QueryRejectShape(shape_: number): void;
/**
 * @param {LuaTable} origin_ Raycast origin as world space vector
 * @param {LuaTable} direction_ Unit length raycast direction as world space vector
 * @param {number} maxDist_ Raycast maximum distance. Keep this as low as possible for good performance.
 * @param {number} [radius_] Raycast thickness. Default zero.
 * @param {boolean} [rejectTransparent_] Raycast through transparent materials. Default false.
 * @returns {boolean} True if raycast hit something
 * @returns {number} Hit distance from origin
 * @returns {LuaTable} World space normal at hit point
 * @returns {number} Handle to hit shape
 */
declare function QueryRaycast(origin_: LuaTable, direction_: LuaTable, maxDist_: number, radius_?: number, rejectTransparent_?: boolean): LuaMultiReturn<[boolean, number, LuaTable, number]>;
/**
 * @param {LuaTable} origin_ World space point
 * @param {number} maxDist_ Maximum distance. Keep this as low as possible for good performance.
 * @returns {boolean} True if a point was found
 * @returns {LuaTable} World space closest point
 * @returns {LuaTable} World space normal at closest point
 * @returns {number} Handle to closest shape
 */
declare function QueryClosestPoint(origin_: LuaTable, maxDist_: number): LuaMultiReturn<[boolean, LuaTable, LuaTable, number]>;
/**
 * @param {LuaTable} min_ Aabb minimum point
 * @param {LuaTable} max_ Aabb maximum point
 * @returns {LuaTable} Indexed table with handles to all shapes in the aabb
 */
declare function QueryAabbShapes(min_: LuaTable, max_: LuaTable): LuaTable;
/**
 * @param {LuaTable} min_ Aabb minimum point
 * @param {LuaTable} max_ Aabb maximum point
 * @returns {LuaTable} Indexed table with handles to all bodies in the aabb
 */
declare function QueryAabbBodies(min_: LuaTable, max_: LuaTable): LuaTable;
/**
 * @param {LuaTable} start_ World space start point
 * @param {LuaTable} end_ World space target point
 * @param {number} [maxDist_] Maximum path length before giving up. Default is infinite.
 * @param {number} [targetRadius_] Maximum allowed distance to target in meters. Default is 2.0
 */
declare function QueryPath(start_: LuaTable, end_: LuaTable, maxDist_?: number, targetRadius_?: number): void;
/**
 */
declare function AbortPath(): void;
/**
 * @returns {string} Current path planning state
 */
declare function GetPathState(): string;
/**
 * @returns {number} Length of last path planning result (in meters)
 */
declare function GetPathLength(): number;
/**
 * @param {number} dist_ The distance along path. Should be between zero and result from GetPathLength()
 * @returns {LuaTable} The path point dist meters along the path
 */
declare function GetPathPoint(dist_: number): LuaTable;
/**
 * @returns {number} Volume of loudest sound played last frame
 * @returns {LuaTable} World position of loudest sound played last frame
 */
declare function GetLastSound(): LuaMultiReturn<[number, LuaTable]>;
/**
 * @param {LuaTable} point_ World point as vector
 * @returns {boolean} True if point is in water
 * @returns {number} Depth of point into water, or zero if not in water
 */
declare function IsPointInWater(point_: LuaTable): LuaMultiReturn<[boolean, number]>;
/**
 * @param {LuaTable} point_ World point as vector
 * @returns {LuaTable} Wind at provided position
 */
declare function GetWindVelocity(point_: LuaTable): LuaTable;
/**
 */
declare function ParticleReset(): void;
/**
 * @param {string} type_ Type of particle. Can be 'smoke' or 'plain'.
 */
declare function ParticleType(type_: string): void;
/**
 * @param {number} type_ Tile in the particle texture atlas (0-15)
 */
declare function ParticleTile(type_: number): void;
/**
 * @param {number} r0_ Red value
 * @param {number} g0_ Green value
 * @param {number} b0_ Blue value
 * @param {number} [r1_] Red value at end
 * @param {number} [g1_] Green value at end
 * @param {number} [b1_] Blue value at end
 */
declare function ParticleColor(r0_: number, g0_: number, b0_: number, r1_?: number, g1_?: number, b1_?: number): void;
/**
 * @param {number} r0_ Radius
 * @param {number} [r1_] End radius
 * @param {string} [interpolation_] Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.
 * @param {number} [fadein_] Fade in between t=0 and t=fadein. Default is zero.
 * @param {number} [fadeout_] Fade out between t=fadeout and t=1. Default is one.
 */
declare function ParticleRadius(r0_: number, r1_?: number, interpolation_?: string, fadein_?: number, fadeout_?: number): void;
/**
 * @param {number} a0_ Alpha (0.0 - 1.0)
 * @param {number} [a1_] End alpha (0.0 - 1.0)
 * @param {string} [interpolation_] Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.
 * @param {number} [fadein_] Fade in between t=0 and t=fadein. Default is zero.
 * @param {number} [fadeout_] Fade out between t=fadeout and t=1. Default is one.
 */
declare function ParticleAlpha(a0_: number, a1_?: number, interpolation_?: string, fadein_?: number, fadeout_?: number): void;
/**
 * @param {number} g0_ Gravity
 * @param {number} [g1_] End gravity
 * @param {string} [interpolation_] Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.
 * @param {number} [fadein_] Fade in between t=0 and t=fadein. Default is zero.
 * @param {number} [fadeout_] Fade out between t=fadeout and t=1. Default is one.
 */
declare function ParticleGravity(g0_: number, g1_?: number, interpolation_?: string, fadein_?: number, fadeout_?: number): void;
/**
 * @param {number} d0_ Drag
 * @param {number} [d1_] End drag
 * @param {string} [interpolation_] Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.
 * @param {number} [fadein_] Fade in between t=0 and t=fadein. Default is zero.
 * @param {number} [fadeout_] Fade out between t=fadeout and t=1. Default is one.
 */
declare function ParticleDrag(d0_: number, d1_?: number, interpolation_?: string, fadein_?: number, fadeout_?: number): void;
/**
 * @param {number} d0_ Emissive
 * @param {number} [d1_] End emissive
 * @param {string} [interpolation_] Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.
 * @param {number} [fadein_] Fade in between t=0 and t=fadein. Default is zero.
 * @param {number} [fadeout_] Fade out between t=fadeout and t=1. Default is one.
 */
declare function ParticleEmissive(d0_: number, d1_?: number, interpolation_?: string, fadein_?: number, fadeout_?: number): void;
/**
 * @param {number} r0_ Rotation speed in radians per second.
 * @param {number} [r1_] End rotation speed in radians per second.
 * @param {string} [interpolation_] Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.
 * @param {number} [fadein_] Fade in between t=0 and t=fadein. Default is zero.
 * @param {number} [fadeout_] Fade out between t=fadeout and t=1. Default is one.
 */
declare function ParticleRotation(r0_: number, r1_?: number, interpolation_?: string, fadein_?: number, fadeout_?: number): void;
/**
 * @param {number} s0_ Stretch
 * @param {number} [s1_] End stretch
 * @param {string} [interpolation_] Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.
 * @param {number} [fadein_] Fade in between t=0 and t=fadein. Default is zero.
 * @param {number} [fadeout_] Fade out between t=fadeout and t=1. Default is one.
 */
declare function ParticleStretch(s0_: number, s1_?: number, interpolation_?: string, fadein_?: number, fadeout_?: number): void;
/**
 * @param {number} s0_ Sticky (0.0 - 1.0)
 * @param {number} [s1_] End sticky (0.0 - 1.0)
 * @param {string} [interpolation_] Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.
 * @param {number} [fadein_] Fade in between t=0 and t=fadein. Default is zero.
 * @param {number} [fadeout_] Fade out between t=fadeout and t=1. Default is one.
 */
declare function ParticleSticky(s0_: number, s1_?: number, interpolation_?: string, fadein_?: number, fadeout_?: number): void;
/**
 * @param {number} c0_ Collide (0.0 - 1.0)
 * @param {number} [c1_] End collide (0.0 - 1.0)
 * @param {string} [interpolation_] Interpolation method: linear, smooth, easein, easeout or constant. Default is linear.
 * @param {number} [fadein_] Fade in between t=0 and t=fadein. Default is zero.
 * @param {number} [fadeout_] Fade out between t=fadeout and t=1. Default is one.
 */
declare function ParticleCollide(c0_: number, c1_?: number, interpolation_?: string, fadein_?: number, fadeout_?: number): void;
/**
 * @param {number} bitmask_ Particle flags (bitmask 0-65535)
 */
declare function ParticleFlags(bitmask_: number): void;
/**
 * @param {LuaTable} pos_ World space point as vector
 * @param {LuaTable} velocity_ World space velocity as vector
 * @param {number} lifetime_ Particle lifetime in seconds
 */
declare function SpawnParticle(pos_: LuaTable, velocity_: LuaTable, lifetime_: number): void;
/**
 * @param {string} xml_ File name or xml string
 * @param {LuaTable} transform_ Spawn transform
 * @param {boolean} [allowStatic_] Allow spawning static shapes and bodies (default false)
 * @param {boolean} [jointExisting_] Allow joints to connect to existing scene geometry (default false)
 * @returns {LuaTable} Indexed table with handles to all spawned entities
 */
declare function Spawn(xml_: string, transform_: LuaTable, allowStatic_?: boolean, jointExisting_?: boolean): LuaTable;
/**
 * @param {LuaTable} origin_ Origin in world space as vector
 * @param {LuaTable} direction_ Unit length direction as world space vector
 * @param {string} [type_] Shot type, see description, default is 'bullet'
 * @param {number} [strength_] Strength scaling, default is 1.0
 * @param {number} [maxDist_] Maximum distance, default is 100.0
 */
declare function Shoot(origin_: LuaTable, direction_: LuaTable, type_?: string, strength_?: number, maxDist_?: number): void;
/**
 * @param {LuaTable} origin_ Origin in world space as vector
 * @param {number} radius_ Affected radius, in range 0.0 to 5.0
 * @param {string} [type_] Paint type. Can be 'explosion' or 'spraycan'. Default is spraycan.
 * @param {number} [probability_] Dithering probability between zero and one, default is 1.0
 */
declare function Paint(origin_: LuaTable, radius_: number, type_?: string, probability_?: number): void;
/**
 * @param {LuaTable} position_ Hole center point
 * @param {number} r0_ Hole radius for soft materials
 * @param {number} [r1_] Hole radius for medium materials. May not be bigger than r0. Default zero.
 * @param {number} [r2_] Hole radius for hard materials. May not be bigger than r1. Default zero.
 * @param {boolean} [silent_] Make hole without playing any break sounds.
 * @returns {number} Number of voxels that was cut out. This will be zero if there were no changes to any shape.
 */
declare function MakeHole(position_: LuaTable, r0_: number, r1_?: number, r2_?: number, silent_?: boolean): number;
/**
 * @param {LuaTable} pos_ Position in world space as vector
 * @param {number} size_ Explosion size from 0.5 to 4.0
 */
declare function Explosion(pos_: LuaTable, size_: number): void;
/**
 * @param {LuaTable} pos_ Position in world space as vector
 */
declare function SpawnFire(pos_: LuaTable): void;
/**
 * @returns {number} Number of active fires in level
 */
declare function GetFireCount(): number;
/**
 * @param {LuaTable} origin_ World space position as vector
 * @param {number} maxDist_ Maximum search distance
 * @returns {boolean} A fire was found within search distance
 * @returns {LuaTable} Position of closest fire
 */
declare function QueryClosestFire(origin_: LuaTable, maxDist_: number): LuaMultiReturn<[boolean, LuaTable]>;
/**
 * @param {LuaTable} min_ Aabb minimum point
 * @param {LuaTable} max_ Aabb maximum point
 * @returns {number} Number of active fires in bounding box
 */
declare function QueryAabbFireCount(min_: LuaTable, max_: LuaTable): number;
/**
 * @param {LuaTable} min_ Aabb minimum point
 * @param {LuaTable} max_ Aabb maximum point
 * @returns {number} Number of fires removed
 */
declare function RemoveAabbFires(min_: LuaTable, max_: LuaTable): number;
/**
 * @returns {LuaTable} Current camera transform
 */
declare function GetCameraTransform(): LuaTable;
/**
 * @param {LuaTable} transform_ Desired camera transform
 * @param {number} [fov_] Optional horizontal field of view in degrees (default: 90)
 */
declare function SetCameraTransform(transform_: LuaTable, fov_?: number): void;
/**
 * @param {number} degrees_ Horizontal field of view in degrees (10-170)
 */
declare function SetCameraFov(degrees_: number): void;
/**
 * @param {number} distance_ Depth of field distance
 * @param {number} [amount_] Optional amount of blur (default 1.0)
 */
declare function SetCameraDof(distance_: number, amount_?: number): void;
/**
 * @param {LuaTable} pos_ World space light position
 * @param {number} r_ Red
 * @param {number} g_ Green
 * @param {number} b_ Blue
 * @param {number} [intensity_] Intensity. Default is 1.0.
 */
declare function PointLight(pos_: LuaTable, r_: number, g_: number, b_: number, intensity_?: number): void;
/**
 * @param {number} scale_ Time scale 0.1 to 1.0
 */
declare function SetTimeScale(scale_: number): void;
/**
 */
declare function SetEnvironmentDefault(): void;
/**
 * @param {string} name_ Property name
 * @param {any} value0_ Property value (type depends on property)
 * @param {any} [value1_] Extra property value (only some properties)
 * @param {any} [value2_] Extra property value (only some properties)
 * @param {any} [value3_] Extra property value (only some properties)
 */
declare function SetEnvironmentProperty(name_: string, value0_: any, value1_?: any, value2_?: any, value3_?: any): void;
/**
 * @param {string} name_ Property name
 * @returns {any} Property value (type depends on property)
 * @returns {any} Property value (only some properties)
 * @returns {any} Property value (only some properties)
 * @returns {any} Property value (only some properties)
 * @returns {any} Property value (only some properties)
 */
declare function GetEnvironmentProperty(name_: string): LuaMultiReturn<[any, any, any, any, any]>;
/**
 */
declare function SetPostProcessingDefault(): void;
/**
 * @param {string} name_ Property name
 * @param {number} value0_ Property value
 * @param {number} [value1_] Extra property value (only some properties)
 * @param {number} [value2_] Extra property value (only some properties)
 */
declare function SetPostProcessingProperty(name_: string, value0_: number, value1_?: number, value2_?: number): void;
/**
 * @param {string} name_ Property name
 * @returns {number} Property value
 * @returns {number} Property value (only some properties)
 * @returns {number} Property value (only some properties)
 */
declare function GetPostProcessingProperty(name_: string): LuaMultiReturn<[number, number, number]>;
/**
 * @param {LuaTable} p0_ World space point as vector
 * @param {LuaTable} p1_ World space point as vector
 * @param {number} [r_] Red
 * @param {number} [g_] Green
 * @param {number} [b_] Blue
 * @param {number} [a_] Alpha
 */
declare function DrawLine(p0_: LuaTable, p1_: LuaTable, r_?: number, g_?: number, b_?: number, a_?: number): void;
/**
 * @param {LuaTable} p0_ World space point as vector
 * @param {LuaTable} p1_ World space point as vector
 * @param {number} [r_] Red
 * @param {number} [g_] Green
 * @param {number} [b_] Blue
 * @param {number} [a_] Alpha
 */
declare function DebugLine(p0_: LuaTable, p1_: LuaTable, r_?: number, g_?: number, b_?: number, a_?: number): void;
/**
 * @param {LuaTable} p0_ World space point as vector
 * @param {number} [r_] Red
 * @param {number} [g_] Green
 * @param {number} [b_] Blue
 * @param {number} [a_] Alpha
 */
declare function DebugCross(p0_: LuaTable, r_?: number, g_?: number, b_?: number, a_?: number): void;
/**
 * @param {string} name_ Name
 * @param {string} value_ Value
 */
declare function DebugWatch(name_: string, value_: string): void;
/**
 * @param {string} message_ Message to display
 */
declare function DebugPrint(message_: string): void;
/**
 */
declare function UiMakeInteractive(): void;
/**
 */
declare function UiPush(): void;
/**
 */
declare function UiPop(): void;
/**
 * @returns {number} Width of draw context
 */
declare function UiWidth(): number;
/**
 * @returns {number} Height of draw context
 */
declare function UiHeight(): number;
/**
 * @returns {number} Half width of draw context
 */
declare function UiCenter(): number;
/**
 * @returns {number} Half height of draw context
 */
declare function UiMiddle(): number;
/**
 * @param {number} r_ Red channel
 * @param {number} g_ Green channel
 * @param {number} b_ Blue channel
 * @param {number} [a_] Alpha channel. Default 1.0
 */
declare function UiColor(r_: number, g_: number, b_: number, a_?: number): void;
/**
 * @param {number} r_ Red channel
 * @param {number} g_ Green channel
 * @param {number} b_ Blue channel
 * @param {number} [a_] Alpha channel. Default 1.0
 */
declare function UiColorFilter(r_: number, g_: number, b_: number, a_?: number): void;
/**
 * @param {number} x_ X component
 * @param {number} y_ Y component
 */
declare function UiTranslate(x_: number, y_: number): void;
/**
 * @param {number} angle_ Angle in degrees, counter clockwise
 */
declare function UiRotate(angle_: number): void;
/**
 * @param {number} x_ X component
 * @param {number} [y_] Y component. Default value is x.
 */
declare function UiScale(x_: number, y_?: number): void;
/**
 * @param {number} width_ Window width
 * @param {number} height_ Window height
 * @param {boolean} [clip_] Clip content outside window. Default is false.
 * @param {boolean} [inherit_] Inherit current clip region (for nested clip regions)
 */
declare function UiWindow(width_: number, height_: number, clip_?: boolean, inherit_?: boolean): void;
/**
 * @returns {number} Left
 * @returns {number} Top
 * @returns {number} Right
 * @returns {number} Bottom
 */
declare function UiSafeMargins(): LuaMultiReturn<[number, number, number, number]>;
/**
 * @param {string} alignment_ Alignment keywords
 */
declare function UiAlign(alignment_: string): void;
/**
 */
declare function UiModalBegin(): void;
/**
 */
declare function UiModalEnd(): void;
/**
 */
declare function UiDisableInput(): void;
/**
 */
declare function UiEnableInput(): void;
/**
 * @returns {boolean} True if current context receives input
 */
declare function UiReceivesInput(): boolean;
/**
 * @returns {number} X coordinate
 * @returns {number} Y coordinate
 */
declare function UiGetMousePos(): LuaMultiReturn<[number, number]>;
/**
 * @param {number} w_ Width
 * @param {number} h_ Height
 * @returns {boolean} True if mouse pointer is within rectangle
 */
declare function UiIsMouseInRect(w_: number, h_: number): boolean;
/**
 * @param {LuaTable} point_ 3D world position as vector
 * @returns {number} X coordinate
 * @returns {number} Y coordinate
 * @returns {number} Distance to point
 */
declare function UiWorldToPixel(point_: LuaTable): LuaMultiReturn<[number, number, number]>;
/**
 * @param {number} x_ X coordinate
 * @param {number} y_ Y coordinate
 * @returns {LuaTable} 3D world direction as vector
 */
declare function UiPixelToWorld(x_: number, y_: number): LuaTable;
/**
 * @param {number} amount_ Blur amount (0.0 to 1.0)
 */
declare function UiBlur(amount_: number): void;
/**
 * @param {string} path_ Path to TTF font file
 * @param {number} size_ Font size (10 to 100)
 */
declare function UiFont(path_: string, size_: number): void;
/**
 * @returns {number} Font size
 */
declare function UiFontHeight(): number;
/**
 * @param {string} text_ Print text at cursor location
 * @param {boolean} [move_] Automatically move cursor vertically. Default false.
 * @returns {number} Width of text
 * @returns {number} Height of text
 * @returns {number} End x-position of text. Only valid when 'advance cursor' is false
 * @returns {number} End y-position of text. Only valid when 'advance cursor' is false
 */
declare function UiText(text_: string, move_?: boolean): LuaMultiReturn<[number, number, number, number]>;
/**
 * @param {string} text_ A text string
 * @returns {number} Width of text
 * @returns {number} Height of text
 */
declare function UiGetTextSize(text_: string): LuaMultiReturn<[number, number]>;
/**
 * @param {number} width_ Maximum width of text
 */
declare function UiWordWrap(width_: number): void;
/**
 * @param {number} r_ Red channel
 * @param {number} g_ Green channel
 * @param {number} b_ Blue channel
 * @param {number} a_ Alpha channel
 * @param {number} [thickness_] Outline thickness. Default is 0.1
 */
declare function UiTextOutline(r_: number, g_: number, b_: number, a_: number, thickness_?: number): void;
/**
 * @param {number} r_ Red channel
 * @param {number} g_ Green channel
 * @param {number} b_ Blue channel
 * @param {number} a_ Alpha channel
 * @param {number} [distance_] Shadow distance. Default is 1.0
 * @param {number} [blur_] Shadow blur. Default is 0.5
 */
declare function UiTextShadow(r_: number, g_: number, b_: number, a_: number, distance_?: number, blur_?: number): void;
/**
 * @param {number} w_ Width
 * @param {number} h_ Height
 */
declare function UiRect(w_: number, h_: number): void;
/**
 * @param {string} path_ Path to image (PNG or JPG format)
 * @param {number} [x0_] Lower x coordinate (default is 0)
 * @param {number} [y0_] Lower y coordinate (default is 0)
 * @param {number} [x1_] Upper x coordinate (default is image width)
 * @param {number} [y1_] Upper y coordinate (default is image height)
 * @returns {number} Width of drawn image
 * @returns {number} Height of drawn image
 */
declare function UiImage(path_: string, x0_?: number, y0_?: number, x1_?: number, y1_?: number): LuaMultiReturn<[number, number]>;
/**
 * @param {string} path_ Path to image (PNG or JPG format)
 * @returns {number} Image width
 * @returns {number} Image height
 */
declare function UiGetImageSize(path_: string): LuaMultiReturn<[number, number]>;
/**
 * @param {string} path_ Path to image (PNG or JPG format)
 * @param {number} width_ Width
 * @param {number} height_ Height
 * @param {number} borderWidth_ Border width
 * @param {number} borderHeight_ Border height
 */
declare function UiImageBox(path_: string, width_: number, height_: number, borderWidth_: number, borderHeight_: number): void;
/**
 * @param {string} path_ Path to sound file (OGG format)
 * @param {number} [volume_] Playback volume. Default 1.0
 * @param {number} [pitch_] Playback pitch. Default 1.0
 * @param {number} [pan_] Playback stereo panning (-1.0 to 1.0). Default 0.0.
 */
declare function UiSound(path_: string, volume_?: number, pitch_?: number, pan_?: number): void;
/**
 * @param {string} path_ Path to looping sound file (OGG format)
 * @param {number} [volume_] Playback volume. Default 1.0
 */
declare function UiSoundLoop(path_: string, volume_?: number): void;
/**
 * @param {number} amount_ Mute by this amount (0.0 to 1.0)
 * @param {boolean} [music_] Mute music as well
 */
declare function UiMute(amount_: number, music_?: boolean): void;
/**
 * @param {string} path_ Path to image (PNG or JPG format)
 * @param {number} borderWidth_ Border width
 * @param {number} borderHeight_ Border height
 * @param {number} [r_] Red multiply. Default 1.0
 * @param {number} [g_] Green multiply. Default 1.0
 * @param {number} [b_] Blue multiply. Default 1.0
 * @param {number} [a_] Alpha channel. Default 1.0
 */
declare function UiButtonImageBox(path_: string, borderWidth_: number, borderHeight_: number, r_?: number, g_?: number, b_?: number, a_?: number): void;
/**
 * @param {number} r_ Red multiply
 * @param {number} g_ Green multiply
 * @param {number} b_ Blue multiply
 * @param {number} [a_] Alpha channel. Default 1.0
 */
declare function UiButtonHoverColor(r_: number, g_: number, b_: number, a_?: number): void;
/**
 * @param {number} r_ Red multiply
 * @param {number} g_ Green multiply
 * @param {number} b_ Blue multiply
 * @param {number} [a_] Alpha channel. Default 1.0
 */
declare function UiButtonPressColor(r_: number, g_: number, b_: number, a_?: number): void;
/**
 * @param {number} dist_ Press distance
 */
declare function UiButtonPressDist(dist_: number): void;
/**
 * @param {string} text_ Text on button
 * @param {number} [w_] Button width
 * @param {number} [h_] Button height
 * @returns {boolean} True if user clicked button
 */
declare function UiTextButton(text_: string, w_?: number, h_?: number): boolean;
/**
 * @param {number} path_ Image path (PNG or JPG file)
 * @returns {boolean} True if user clicked button
 */
declare function UiImageButton(path_: number): boolean;
/**
 * @param {number} w_ Button width
 * @param {number} h_ Button height
 * @returns {boolean} True if user clicked button
 */
declare function UiBlankButton(w_: number, h_: number): boolean;
/**
 * @param {number} path_ Image path (PNG or JPG file)
 * @param {string} axis_ Drag axis, must be 'x' or 'y'
 * @param {number} current_ Current value
 * @param {number} min_ Minimum value
 * @param {number} max_ Maximum value
 * @returns {number} New value, same as current if not changed
 * @returns {boolean} True if user is finished changing (released slider)
 */
declare function UiSlider(path_: number, axis_: string, current_: number, min_: number, max_: number): LuaMultiReturn<[number, boolean]>;
/**
 * @returns {number} Handle to the screen running this script or zero if none.
 */
declare function UiGetScreen(): number;